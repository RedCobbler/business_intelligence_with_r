# Chapter 9: Reporting and Dashboarding

- Reports and Technical Memos
- Dashboards
- Slide Decks 
- Shiny Apps
- Reproducible Analytics


## Reports

Reports are typically look-back affairs, and can range from a simple dataset or table, to a set of KPI graphs on a single webpage, to a full-blown, multi-tab overview of a group of activities. The vast majority of analytics in modern BI tend to be report-oriented. Technical memos are usually one-off analytic products that answer a specific question, but can also provide guidance on next steps. 

We saw an example of a data product that could be considered either in Chapter 1, in the exploration and forecasting of the Hauteville House's power consumption. 

Basically, just open a new R Markdown document, choose Document, and hit OK. A default template will open in the Source window, from which you can modify as needed. Code occurs in "chunks", sections in which you place the code you want R to execute. Free text is converted into html via [R Markdown](http://rmarkdown.rstudio.com), a flavor of the Markdown language that provides simple shortcuts to convert the raw text into formatted html. See Appendix 3 for a cheatsheet of R Markdown symbols and usage.  

Web (html) reports are ready to create out-of-the-box. To create PDF or Word documents, you need to install programs on your machine that do not come with R. For PDF, you need a TeX program, and for Word docs you need either Word or Libre/Open Office. 


## Dashboards

There are a lot of dashboards in BI that don't deserve the name. Just because you have graphs and interactivity doesn't mean you have a real dashboard; much like driving a car, if you're getting information about how fast you were going 10 minutes ago, it's not of much use. Dashboards are about real-time analytics.  

Forecasting fits into this group as well, much as a GPS or driving app provides you information about where you're going. 


## Slide Decks and Shiny Apps

At some point, every analyst needs to report their results in a meeting or briefing. Traditional static slide decks are fine, but one of the powerful features of R is the ability to create slide decks or apps with interactive features, allowing the analyst to help decision makers explore the results and their implications interactively, in real time. 


`ioslides` has a great default style, but I've found that some rooms (especially those with a lot of natural light) aren't amenable to the grey text. To change this, get the latest ioslides style sheet (as of this writing it is [here](rmarkdown/inst/rmd/ioslides/ioslides-13.5.1/theme/css/default.css)), and save it as a `.css` file into the same directory where you are saving your `.Rmd` file. I change the grey to black for these types of rooms by making these changes in the stylesheet:

| Line | Style block | Original setting | Change to: |
| ---- | ----------- | ---------------- | ---------- |
| 245 | `slides > slide` | `color: #797979;` | `color: black;` |
| 454 | `h2` | `color: #515151;` | `color: black;` |
| 463 | `h3` | `color: #797979;` | `color: black;` |
| 1339 | `.title-slide hgroup h1` | `color: #515151;` | `color: black;` |
| 1344 | `.title-slide hgroup h2` | `color: darkgrey;` | `color: black;` |
| 1339 | `.title-slide hgroup p` | `color: #797979;` | `color: black;` |

I save this new stylesheet as `default_black.css`. Then, in the YAML header of your `.Rmd` file, change ```output: ioslides_presentation`` to (spacing matters!):

```
output:
  ioslides_presentation:
    css: default_black.css
```

As long as you have both the `.css` and `.Rmd` files in the same place, it will make the conversion for you. Obviously, any style element can be changed in the same way, so even if you don't know css, you can probably web search what you want to change to find out what that particular element is named in html, and go from there.  


## Shiny Apps

Shiny is an incredible tool--being able to update parameters and inputs on the fly is a tremendous improvement for decision makers in exploring "what if?" scenarios alogside the analyst. Basically, if you can do it in R, you can do it in Shiny. RStudio's Shiny page is a wealth of knowledge, demos, and examples you can pull from to create your own app. 

A great use of Shiny is for risk assessment, where the decision maker can see the effects of assumptions on the probability of a value or range of values occuring in real time. (This can be dangerous as well, if they change their assumptions to obtain the outcome they want to see!) 

Below is the code and a screenshot of an app that uses the basic risk assessment tool of the [betaPERT distribution](https://www.riskamp.com/beta-pert) to create a probability model of expert opinion, where the subject matter expert provides the value of minimum and maximum possible values as well as the most likely value. An uncertainty parameter *gamma* provides the user with the ability to modify the kurtosis of the distribution; a value of 4 is the [standard betaPERT](http://vosesoftware.com/ModelRiskHelp/index.htm#Distributions/Continuous_distributions/PERT_distribution.htm), while lower values show increased uncertainty and larger values show increased certainty in the estimate of the most likely value (termed the [modified betaPERT](http://vosesoftware.com/ModelRiskHelp/index.htm#Distributions/Continuous_distributions/PERT_distribution.htm). 

```
#############################################################
# Risk Explorer Shiny App
# Dwight Barry, PhD | Enterprise Analytics
# November 2015 - Version 0.9 - Proof of concept
# May 2016 - Version 1.2 - expert opinion only
# Changes from 1.0: added data input and mix/max adjustment
# Changes from 1.1: substituted function for mc2d rpert,
#                   removed min values from inputs
#############################################################


##### Global #####

# Load Packages
library(shiny)
library(ggplot2)
library(htmlTable)
library(mc2d)


#######################################################

##### User Interface #####

ui = shinyUI(fluidPage(
  # Title
  titlePanel("Expert Opinion Risk Explorer"),
  
  sidebarLayout(
    # Sidebar Panel
    
    sidebarPanel(
      # Allow user to input betaPERT parameters
      
      # Enter lowest possible value
      numericInput(
        "low",
        label = "Enter Lowest Possible Value:",
        value = 0,
        step = 0.1
      ),
      
      # Enter most likely value (mode/maximum density)
      numericInput(
        "mode",
        label = "Enter Most Likely Value (Mode):",
        value = 10,
        step = 0.1
      ),
      
      # Enter highest possible value
      numericInput(
        "high",
        label = "Enter Highest Possible Value:",
        value = 25,
        step = 0.1
      ),
      
      # Produce empirical histogram/density plot
      numericInput(
        "bins",
        label = "Bin Width (0 for density only):",
        min = 0,
        value = 0.1,
        step = 0.1
      ),
      
      # User inputs for min/max percent adjustment
      numericInput(
        "minperc",
        label = "Minimum adjustment (percent below minimum):",
        min = 0,
        max = 1,
        value = 0
      ),
      
      numericInput(
        "maxperc",
        label = "Maximum adjustment (percent above maximum):",
        min = 0,
        max = 1,
        value = 0
      ),
      
      # Show betaPERT values
      htmlOutput("maxdens"),
      
      br(),
      
      # User inputs for simulation
      numericInput(
        "reps",
        label = "Simulation Replications:",
        min = 1,
        value = 10000
      ),
      
      sliderInput(
        "gamma",
        label = HTML(
          "BetaPERT Distribution Uncertainty Parameter (&gamma;): <br>
          <small><i>4 is default PERT
          distribution</i></small>"
        ),
        min = 1,
        max = 10,
        value = 4,
        step = 1
        ),
      
      submitButton("Submit")
      
      ),
    
    # Main panel
    mainPanel(
      
      # Simulation histogram/density plot
      plotOutput(outputId = "dist_plot"),
      
      # Output of simulation cdf plot click
      
      HTML(
        "<br><b>Click on the CDF line for a given Value value, 
        then click <i>Submit</i> to obtain the probability estimate.</b><br>"
      ),
      
      br(),
      
      # Simulation cdf plot
      plotOutput(outputId = "cdf_plot", click = "plot_click"),
      
      # Click output results
      htmlOutput("info")
      
      )
    
  )
  
))


#######################################################

##### Server #####

server = shinyServer(function(input, output) {
  
  # Simulation distribution plot
  output$dist_plot = renderPlot({
    Value = c(input$low, input$high, input$mode)
    df = data.frame(Value)
    
    sim_df = data.frame(Value = rpert(
      input$reps,
      (min(df$Value) - min(df$Value) * input$minperc),
      input$mode,
      (max(df$Value) + max(df$Value) * input$maxperc),
      input$gamma))
    
    ggplot(sim_df, aes(Value)) +
      ggtitle("Simulation Distribution") +
      ylab("Density / Count") +
      geom_histogram(
        aes(y = ..density..),
        binwidth = input$bins,
        col = "blue",
        fill = "blue",
        alpha = 0.2,
        na.rm = T) +
      xlim((min(df$Value) - min(df$Value) * input$minperc),
           (max(df$Value) + max(df$Value) * input$maxperc)) +
      geom_density(
        col = "blue",
        fill = "blue",
        alpha = 0.2,
        na.rm = T) +
      theme(
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank())
  })
  
  # Simulation CDF plot
  output$cdf_plot = renderPlot({
    Value = c(input$low, input$high, input$mode)
    df = data.frame(Value)
    
    sim_df = data.frame(Value = rpert(
      input$reps,
      (min(df$Value) - min(df$Value) * input$minperc),
      input$mode,
      (max(df$Value) + max(df$Value) * input$maxperc),
      input$gamma
    ))
    
    ggplot(sim_df, aes(Value)) +
      ggtitle("Simulation CDF") +
      ylab("Probability") +
      xlim((min(df$Value) - min(df$Value) * input$minperc),
           (max(df$Value) + max(df$Value) * input$maxperc)) +
      stat_ecdf(lwd = 2, na.rm = T) +
      theme(axis.ticks.y = element_blank(), axis.text.y = element_blank())
    
  })
  
  # Plot-click result for simulation
  output$info = renderText({
    paste0(
      "<i>The probability of obtaining a Value less than
      or equal to ",
      txtRound(input$plot_click$x, 1),
      " is about <b>",
      txtRound(input$plot_click$y, 2),
      "</b>.</i>"
    )
    
  })
  
  # Details on betaPERT parameters
  output$maxdens = renderText({
    Value = c(input$low, input$high, input$mode)
    df = data.frame(Value)
    
    sim_df = data.frame(Value = rpert(
      input$reps,
      (min(df$Value) - min(df$Value) * input$minperc),
      input$mode,
      (max(df$Value) + max(df$Value) * input$maxperc),
      input$gamma
    ))
    
    
    paste0(
      "<b>BetaPERT Inputs:</b><br><i>Simulation mode: ",
      txtRound(input$mode, 1),
      ".<br>Simulation minimum: ",
      txtRound((min(df$Value) - min(df$Value) * input$minperc), 1),
      "<br>Simulation maximum: ",
      txtRound(max(df$Value) + max(df$Value) * input$maxperc, 1),
      "</i>."
    )
    
  })
  
})


#######################################################

##### App #####

# Return the Shiny app
shinyApp(ui = ui, server = server)

#######################################################
```

![risk app](images/risk_app.png)

## Reproducible Analytics

In research and academia, there is increasing emphasis on reproducible research, the idea that *any* analytic product can be reproduced by an independent analyst. Industry is starting to adopt the same philosophy, where ideally any analytic product created in one division of a company can be completely reproduced (and often subsequently modified) by another division, without having to spend time and resources reverse-engineering it. 
