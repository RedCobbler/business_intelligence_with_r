# Chapter 1: An entire project in a few lines of code

Learning R is an infamously difficult thing to do. However, learning to do *x* with R can be pretty simple. Most business intelligence analysts just need to accomplish a set of particular tasks, many of which can be done relatively easily in R.

Essentially, the technial part of the typical BI workflow is
1. Set up and develop project space
2. Acquire data
3. Wrangle data
4. Perform analytics
5. Develop report/data product
6. Document the process

This chapter shows how simple it can be do some advanced analytics in R, working through each of these six steps.

## The Analytics Problem

The data we'll use in this chapter contains 2+ million records of minute-scale power consumption in a single household for about 47 months, collected by Electricité de France and archived at the UCI Machine Learning Repository. The data set's page can be accessed [here](https://archive.ics.uci.edu/ml/datasets/Individual+household+electric+power+consumption) for more details, but for convience, the attributes of this dataset are as follows:

1. *`date`*: Date in format dd/mm/yyyy
2. *`time`*: time in format hh:mm:ss
3. *`global_active_power`*: household global minute-averaged active power (in kilowatt)
4. *`global_reactive_power`*: household global minute-averaged reactive power (in kilowatt)
5. *`voltage`*: minute-averaged voltage (in volt)
6. *`global_intensity`*: household global minute-averaged current intensity (in ampere)
7. *`sub_metering_1`*: energy sub-metering No. 1 (in watt-hour of active energy). It corresponds to the kitchen, containing mainly a dishwasher, an oven and a microwave (hot plates are not electric but gas powered).
8. *`sub_metering_2`*: energy sub-metering No. 2 (in watt-hour of active energy). It corresponds to the laundry room, containing a washing-machine, a tumble-drier, a refrigerator and a light.
9. *`sub_metering_3`*: energy sub-metering No. 3 (in watt-hour of active energy). It corresponds to an electric water-heater and an air-conditioner.

Our purpose is to describe past monthly power usage and forecast potential usage for six months following the last full month of data in the dataset.


## Set up

First, we need to set up the working environment—this is generally easiest to do using the file system (see Appendix 1), but for sake of explanation and thoroughness, we'll do the entire process in this chapter within R. To ensure clarity and reproducibility, we need to set up a single directory for each project, with subfolders that contain and separate code, data, results, and so on. 

Open RStudio. 

R starts in the default directory, symbolized at the top of the console window as `~/`. 

Create the directory space with `dir.create`, the R equivalent to `mkdir`:

```
# Creates directory/ies, use recursive=TRUE in the first
# command to create the entire path at once
dir.create("~/BIWR/Chapter1/Code", recursive=T)
dir.create("~/BIWR/Chapter1/Data")
dir.create("~/BIWR/Chapter1/Results")
```

Normally, at this point we'd use the script window to write out the script, often using R Markdown to create the documentation as we go. For now, you either cut and paste each line into the console as we go, or open a new R Script window and put the code as-is into that. At the end of this chapter, we'll go through the entire process using an R Markdown file to document the project and create a final data product. 

Move into your new directory and load the R packages we'll use in this project:

```
# Set the working directory
setwd("~/BIWR/Chapter1")

# This package allows us to explore time values separate from date values
require(chron)

# This package will allow us to interpolate between missing values
require(zoo)

# This package provides functions for easy data wrangling
require(dplyr)

# This package provides automated forecasting of time series data
require(forecast)

# This package allows us to create publication-quality plots
require(ggplot2)

# This package allows creation of javascript widgets for use in webpages
require(htmlwidgets)

# This packages uses html widgets to make time series widgets
require(dygraphs)
```


## Acquire Data


Download the data from a zipped flat file (semi-colon delimted .txt format) on the UCI Machine Learning Repository:

```
# Download the zip file into the data folder
download.file("http://archive.ics.uci.edu/ml/machine-learning-databases/00235/household_power_consumption.zip", destfile = "Data/household_power_consumption.zip")

# Unzip the data from the zip file into the Data folder
unzip("Data/household_power_consumption.zip", exdir="Data")

# Read the data into R using data.table package's fread command
# NAs are represented by blanks and ? in this data, so need to change
power = read.table("Data/household_power_consumption.txt", sep=";", header=T, na.strings=c("?",""), stringsAsFactors=FALSE)
```

***CONVERT TO fread?***
Incidentally, reading in the data with `read.table` (see Chapter 2) took about 23 seconds on my 16G i7 core Linux laptop, and only 2 seconds using `fread`. 


## Wrangling Data

We'll look at the structure of the data to see what's been read in:

```
# str gives you the structure of the dataset
str(power)

'data.frame':	2075259 obs. of  9 variables:
 $ Date                 : chr  "16/12/2006" "16/12/2006" "16/12/2006" "16/12/2006" ...
 $ Time                 : chr  "17:24:00" "17:25:00" "17:26:00" "17:27:00" ...
 $ Global_active_power  : num  4.22 5.36 5.37 5.39 3.67 ...
 $ Global_reactive_power: num  0.418 0.436 0.498 0.502 0.528 0.522 0.52 0.52 0.51 0.51 ...
 $ Voltage              : num  235 234 233 234 236 ...
 $ Global_intensity     : num  18.4 23 23 23 15.8 15 15.8 15.8 15.8 15.8 ...
 $ Sub_metering_1       : num  0 0 0 0 0 0 0 0 0 0 ...
 $ Sub_metering_2       : num  1 1 2 1 1 2 1 1 1 2 ...
 $ Sub_metering_3       : num  17 16 17 17 17 17 17 17 17 16 ...
```

The Date and Time variables were read in as characters, so we'll convert them to date and time classes, respectively, as well as create a new DateTime column:

```
# Convert data to Date object
power$Date = as.Date(power$Date, format="%d/%m/%Y")

# Create a DateTime object
power$DateTime = as.POSIXct(paste(power$Date, power$Time))

# Obtain the Month and Year for each data point
power$Month = format(power$Date,"%Y-%m")

# Verify the changes
str(power)

'data.frame':	2075259 obs. of  10 variables:
 $ Date                 : Date, format: "2006-12-16" "2006-12-16" "2006-12-16" ...
 $ Time                 :Class 'times'  atomic [1:2075259] 0.725 0.726 0.726 0.727 0.728 ...
  .. ..- attr(*, "format")= chr "h:m:s"
 $ Global_active_power  : num  4.22 5.36 5.37 5.39 3.67 ...
 $ Global_reactive_power: num  0.418 0.436 0.498 0.502 0.528 0.522 0.52 0.52 0.51 0.51 ...
 $ Voltage              : num  235 234 233 234 236 ...
 $ Global_intensity     : num  18.4 23 23 23 15.8 15 15.8 15.8 15.8 15.8 ...
 $ Sub_metering_1       : num  0 0 0 0 0 0 0 0 0 0 ...
 $ Sub_metering_2       : num  1 1 2 1 1 2 1 1 1 2 ...
 $ Sub_metering_3       : num  17 16 17 17 17 17 17 17 17 16 ...
 $ DateTime             : POSIXct, format: "2006-12-16 17:24:00" "2006-12-16 17:25:00" "2006-12-16 17:26:00" ...
 
# Get an overview of the variables
summary(power)
```

We can see from the summary that there are missing values (`NAs`) in our primary variable, `Global_active_power`. We can quickly get a table and graph of missing data over time by using `dplyr` to group and summarize the data, and use a function to create a calendar graph by pulling it from a website.  

```
# Use 'ifelse' to count each minute that is NA
power$Missing = ifelse(is.na(power$Global_active_power), 1, 0)

# Use 'dplyr' to group the data by Date
power_group_day = group_by(power, Date)

# Use 'dplyr' to summarize by our NA indicator 
# (where 1 = 1 minute with NA)
power_day_missing = summarise(power_group_day, Count_Missing = sum(Missing))

# Download the 'calendarHeat' function from revolutionanalytics.com
source("http://blog.revolutionanalytics.com/downloads/calendarHeat.R")

# Plot the calendar graph to view the missing data pattern
calendarHeat(power_day_missing$Date, power_day_missing$Count_Missing, 
  varname="Missing Data", color="w2b")
```

You can view the the actual values of missing data on each day by viewing `power_day_missing`. Since we want to perform automated forecasting, we need to fill in those missing values. If we convert each missing value to 0, we'll definitely underestimate usage for those times. A reasonable first pass is to carry the last value forward, which we can do with the `na.locf` function in the `zoo` package. 

```
# Use 'zoo' to perform interpolation for missing values
power$Global_active_power_locf = na.locf(power$Global_active_power)
```

Now that we have a complete time series, we can determine total monthly use (kWh) and maximum demand for a given month (kW) over the period of record. 

```
# Use 'dplyr' to group by month
power_group = group_by(power, Month)

# Use 'dplyr' to get monthly max demand and total use results
power_daily = summarise(power_group, Max_Demand_kW = max(Global_active_power_locf), 
        Total_Use_kWh = sum(Global_active_power_locf)/60)

# Look at structure of the result
str(power_daily)
```

















```
# Convert time to Time object using the chron package
power$Time = times(power$Time)

# get a mean clock time for peak demand

```

Create an interactive plot:

```
# Create an R time series object
discharges_ts = ts(discharges$DISCHARGES, start=c(2008,10), frequency=12)
# Do a quick prediction (no options explored! Just an EXAMPLE!)
hw = HoltWinters(discharges_ts)
predicted = predict(hw, n.ahead = 24, prediction.interval = TRUE)
all = cbind(discharges_ts, predicted)
# Create the widget with the slider set to current fiscal year
discharges_prediction_widget = 
    dygraph(all, main = "Predicted Monthly Discharges") %>%
    dySeries("discharges_ts", label = "Monthly Discharges") %>%
    dySeries(c("predicted.lwr", "predicted.fit", "predicted.upr"), 
                label = "Predicted Discharges") %>%
    dyRangeSelector(dateWindow = c("2012-10-01", "2016-10-01"))
# Open the widget
discharges_prediction_widget
```

Save the widget to the working directory:

```
saveWidget(discharges_prediction_widget, "discharges_predictions.html")
```

